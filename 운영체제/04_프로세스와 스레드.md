# 04_프로세스와 스레드

CPU의 작업 처리 방식과 프로세스, 스레드에 대한 이해

<br>

## 1. CPU의 작업 처리 방식

병렬성과 동시성

### 1) 병렬성(Parallelism)

물리적으로 여러 작업들을 동시에 수행하는 것

현대의 CPU는 다수의 코어가 존재하여 병렬적으로 다수의 작업을 동시에 처리할 수 있다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/244c377a-55bb-42b5-8eb9-f09bb382d4d0)

### 2) 동시성(Concurrency)

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/156fb1b6-a086-4de5-98df-e74278e57d91)

둘 이상의 작업이 동시에 실행되는 것을 의미한다.

그러나, 동시성에서 말하는 동시는 병렬성에서 말하는 동시와 차이가 있다.

병렬성에서 말하는 동시는 말 그대로 정말 물리적으로 동시에 실행하는 것인 반면, 동시성에서 말하는 동시란 `동시에 실행되는 것처럼 보이는 것`을 의미한다.

실제로 한 개의 코어에 여러 개의 작업이 있으면 CPU는 이 작업들을 계속해서 번갈아가며 조금씩 처리한다. CPU가 매우 빠르게 동작하면서 이 과정을 수행하기 때문에 거의 동시에 수행하는 것처럼 느껴지는 것이고, 이를 동시성이라고 하는 것이다.

#### 왜 동시성이 필요한가?

상식적으로 보면 실제로 동시에 작업을 처리하는 것도 아니고, 번거롭게 매번 이 작업, 저 작업 왔다 갔다 하는데, 최종 작업 시간에 큰 차이도 없을 것인데 왜 이렇게 처리하는 것일까?

- 하드웨어적 한계
  - 현대의 CPU 성능이 과거에 비해 매우 많이 향상된 것은 사실이나, 물리적으로 수십 개의 코어를 넣어서 구성하기에는 무리가 있을 뿐더러 성능도 엄청 크게 향상되지 않고, 발열 등의 문제가 생기게 된다.
  - 따라서 적은 코어 수로 수십 수백 프로세스를 효율적으로 돌리기 위해서는 동시성의 개념이 필요한 것이다.
- 논리적인 효율성
  - 만일 번갈아가며 작업을 처리하지 않는다면, 오래 걸리는 작업이 먼저 들어오게 될 경우 해당 작업을 끝내기 전까지는 다른 작업을 할 수 없게 된다.
  - 그 후에 작업 시간이 적게 걸리는 작업을 수행한다 해도, 총 작업 시간은 작업 시간이 적은 작업을 먼저 수행하고, 오래 걸리는 작업을 나중에 수행하는 것과 큰 차이가 없다.
  - 그러나 중간 중간에 작업을 잘게 나눠 처리함으로써 동시에 여러 작업을 수행하는 것처럼 보이게 되어 일부 작업들이 빨리, 동시에 끝나는 것처럼 느껴지게 함으로써 논리적인 효율성을 가져가는 것이다.

<br>

## 2. 프로세스

> *"Process in a program in execution"*

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/9252c443-9a32-43a0-ad6c-3923a5b3cadc)

### 1) 정의

**★☆프로세스는 실행 중인 프로그램☆★**이다.

<br>

### 2) 프로세스의 문맥(Context)

> 프로그램을 어떻게 실행했고, 현재 어떤 상태인지 표현 또는 표현하기 위한 정보들의 집합

 **★☆현대의 시스템에선 프로세스가 번갈아가며 실행되기 때문에 프로세스 문맥이 중요함☆★**

예) program counter가 어디를 가르키고 있는가, 레지스터에 어떤 값이 기록되어 있는가, 메모리에 어떤 내용이 쌓여 있는가, 데이터 상태는 어떤가, 어디까지 실행했는가 등

- CPU 수행 상태를 나타내는 하드웨어 문맥
  - program counter, register
- 프로세스의 주소 공간
  - code, data, stack
- 프로세스 관련 커널 자료 구조
  - PCB(process control block), 커널 스택

<br>

### 3) 프로세스의 상태

`프로세스의 상태 != 운영체제의 상태`. 프로세스의 상태와 운영체제의 상태는 전혀 다른 말이며 같은 말이 아님을 유의!

#### 프로세스 상태도

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/96f4bb8a-5831-4d17-891c-569b8284ad35)

- **New** : 프로세스가 새롭게 생성된 혹은 생성 중인 상태
- **Ready** : 메모리 등 다른 조건은 전부 다 만족한 상태에서 CPU의 제어권이 넘어오기를 기다리는 상태(CPU 제어권만 얻으면 실행 가능한 상태)
- **Running** : CPU의 제어권을 갖고 Instruction을 수행 중인 상태
- **Block(Wait, Sleep)** : CPU 제어권을 주어도 당장 Instruction을 수행할 수 없는 상태. 또는 프로세스가 요청한 Event가 아직 만족되지 않아 기다리는 상태. 예) - 디스크에서 파일을 읽어와야 하는 경우
- **Suspended(Stop)** : 외부적인 이유로 프로세스의 수행이 정지된 상태(Block과 구분 유의). 프로세스가 메모리에서 쫓겨나 디스크로 swap out된 상태. 예) -  사용자가 프로그램을 일시 중지 시킨 경우, 시스템이 여러 이유로 프로세스를 중단 시킨 경우(메모리에 프로세스가 너무 많이 올라와 있어서 중기 스케줄러가 쫓아낸 경우)
- **Terminated** : 프로세스 수행(Execution)이 끝난 상태(단, 정리할 것은 아직 남아 있음)

※ Block과 Suspend의 구분

- Block : 프로그램이 자발적으로 I/O와 같은 다른 일을 위해서 CPU의 제어권을 내려놓고 그 일을 하러 간 것. 따라서 자신이 요청한 Event가 완료되면 다시 Ready 상태로 바뀜(계속 active한 상태)
- Suspend : 외부에서 resume해줘야만 다시 active 상태가 되는 상태(현재 inactive한 상태)

※ 사용자 프로세스가 user mode에서 시스템 콜을 호출해서 monitor mode로 들어갔다고 해서 "현재 커널 또는 운영체제가 running 중이다." 라고 표현하지는 않음.

- 프로세스의 상태는 운영체제가 관리를 위해 분류한 것이지 운영체제의 상태가 아니며, 사용자 프로세스가 kernel mode 또는 monitor mode에서 running하고 있다고 간주, 표현함.
- 운영체제는 항시 실행 중인 상태임.

<br>

### 4) PCB(Process Control Block)

>  운영체제가 프로세스를 관리하기 위해 프로세스 당 유지하는 정보

![image](https://user-images.githubusercontent.com/93081720/162721874-2f8b1dc9-b9d1-4ea8-ba95-2a4f48007079.png)

프로세스 1개당 PCB도 1개씩 존재한다. 즉, 프로세스가 생성되면 메모리에 해당 프로세스의 PCB도 함께 생성되고, 프로세스 종료 시에 삭제된다.

※ 빨간색 음영 처리한 부분은 프로세스의 각 스레드별로 서로 공유하지 않고 독립적으로 해당 정보를 가지고 있다고 표현한 것임

(1) OS가 관리상 사용하는 정보

- 프로세스 상태, 프로세스 ID, 스케줄링 정보, 우선순위 등

(2) CPU 수행 관련 하드웨어 값

- 프로그램 카운터, 레지스터 등

(3) 메모리 관련 정보

- code, data, stack의 위치 정보 등

(4) 파일 관련 정보

- 파일 open/closed 상태 등

<br>

### 5) 문맥 교환(컨텍스트 스위칭, Context Switching)

> CPU의 제어권을 한 프로세스에서 다른 프로세스로 넘겨주는 과정

- OS가 하는 일(메커니즘)
  - (1) CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장함
  - (2) 그 후, CPU를 새롭게 얻는 프로세스의 상태를 그 프로세스의 PCB에서 읽어옴

※ **시스템 콜이나 인터럽트가 발생했다고 해서 반드시 Context Switch가 발생하는 것은 아님**. 시스템 콜, 인터럽트를 했지만 `[A 프로세스 유저 모드→ 커널 모드 → A 프로세스 유저]`인 경우도 있기 때문. (단, 이 경우에도 PCB save는 발생한다.) 

|                문맥 교환이 발생하지 않는 경우                |                  문맥 교환이 발생하는 경우                   |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/584bc1ce-5d58-4272-b36d-805da89cd81c) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/25fe1026-bd12-4c2c-8305-f0ab2e7b13d6) |

<br>

### 6) 프로세스 스케줄링을 위한 큐(queue)

**★☆프로세스들은 각 큐들을 오고가며 수행된다☆★** (PCB가 큐에 들어가 있는 개념)

- Job queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready queue : 현재 메모리 내에 있으면서 CPU 제어권을 얻기를 기다려 실행되기를 대기하고 있는 프로세스의 집합

- Device queue : I/O device의 처리를 기다리는 프로세스의 집합

<br>

### 7) 스케줄러(Scheduler)

> 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제의 커널 모듈

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/fc6f4635-6c30-4bcc-8d5d-1e63e1a2824d)

#### 장기 스케줄러(Long-Term Scheduler, Job Scheduler)

> 어떤 프로세스를 준비 큐(Ready Queue)에 보낼 것인가

- 시작 프로세스 중 어떤 프로세스를 준비 큐로 보낼지 결정함(**`new → ready`**)
- **`프로세스에 메모리 및 각종 자원을 주는 문제와 연관`**(메모리에 올라가는 것이 허락되고 나서야 new → ready로 바뀜)
- degree of multiprogramming을 제어(메모리에 올라갈 프로세스의 수를 제어하는 것)
- 보통 우리가 사용하는 time sharing system에는 장기 스케줄러가 없음(무조건 ready 상태)
  - 중기 스케줄러가 degree of multiprogramming을 제어함

<br>

#### 단기 스케줄러(Short-Term Scheduler, CPU Scheduler)

> 어떤 프로세스에게 CPU를 할당해 줄 것인가 (어떤 프로세스를 실행시킬 것인가)

- 다음 번에 어떤 프로세스를 running시킬 지 결정(**`ready → running`**)
- **`프로세스에 CPU 제어권을 주는 문제와 연관`**
- 매우 빠른 시간 단위로 결정됨(밀리세컨드 단위)

<br>

#### 중기 스케줄러(Mid-Term Scheduler, Swapper)

> 어떤 프로세스를 메모리 공간에서 쫓아낼 것인가

- 메모리 여유 공간 확보를 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄(**`Swap In-Out`**)
  - 메모리에 올려져 있는 프로세스 중 일부로부터 메모리를 통째로 빼앗아 디스크의 스왑 영역에 저장해두는 것을 Swap-Out(스왑 아웃)이라고 한다.
  - Swap-In(스왑 인)은 빼앗긴 것을 다시 되돌려 받는 것을 말한다.
- **`프로세스에서 메모리를 빼앗는 문제와 연관`**
- 현대의 System에서 degree of multiprogramming을 제어함

<br>

## 3. 스레드(Thread)

> *"Thread is a basic unit of CPU utilization"*

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/6873a846-4cb4-4a4f-a3a6-19c77aeaf1ae)

### 1) 정의

**★☆프로세스 내부의 CPU의 수행 단위☆★**

프로세스 내에 스레드가 1개인 것을 `싱글 스레드(Single Thread)`, 여러 개인 경우 `멀티 스레드(Multi Thread)`라고 한다.

프로세스가 각 은행의 지점이라고 한다면, 스레드는 해당 은행에 있는 고객 창구로 비유할 수 있다.

|                    프로세스 = 은행 지점들                    |                   스레드 = 각 지점의 창구                    |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/66e80dee-2aa3-4e18-96a1-3cd924486d68) | ![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/704a0c5a-7932-47e0-9e2b-59efaf847b6e) |

<br>

### 2) 스레드의 구성

> 스레드는 어떻게 독립적인 실행 흐름을 가질 수 있는가?

![image](https://user-images.githubusercontent.com/93081720/162721766-04dae777-cc8a-4b55-8d3b-523a3b1e72dc.png)

- Thread의 구성(독립적)
  - program counter
  - register set
  - stack space
- 타 Thread와 공유하는 부분(=Task)
  - code section
  - data section
  - os resource

<br>

### 3) 스레드 사용의 장점

※ 프로세스를 여러 개 두는 것보다 프로세스 하나에 스레드를 여러 개 두는 것이 더 가볍기 때문에 스레드를 `lightweight process(경량 프로세스)`라고도 함

#### 응답 시간의 향상(Responsiveness)

하나의 스레드가 blocked인 상태에서도 동일한 태스크 내의 다른 스레드가 실행(running)되어 빠른 처리가 가능함

#### 높은 처리율, 성능 향상

동일한 일을 수행하는 스레드가 협력하여 일을 함
- 만약 같은 일에 대해 별도의 프로세스를 여럿 둔다면, 메모리 및 자원 낭비가 발생하여 경제성이 떨어짐

#### 병렬성 향상

병렬성 향상(멀티 CPU한정)

<br>

### 4) 싱글 스레드 vs. 멀티 스레드

모든 상황에서 무조건 멀티 스레드가 싱글 스레드보다 좋다고 할 수 없다.

