# 00_Web RTC

> Web Real Time Communication

## 1. Web RTC란?

WebRTC란 웹 브라우저 간에 소프트웨어나 플러그인의 도움 없이 서로 P2P 방식으로 실시간 통신할 수 있도록 설계된 API이다.

실시간 통신의 범주에는 음성 통화, 영상(화상) 통화, P2P 파일 공유 등이 포함된다.

![image](https://github.com/siwon-park/cs-study-for-interview/assets/93081720/dd4ff1c2-dc5d-4a57-926b-42f8a96d4f00)

### 1) 특징

- 오픈 소스 프레임워크(라이브러리)
- C++, Javascript로 개발됨
  - 특히, Javascript로 개발된 API를 제공함으로써 웹 브라우저에서 손쉽게 RTC web app을 실행할 수 있다.
- 실시간 데이터를 주고 받기 위해 어떤 소프트웨어나 플러그인의 도움이 필요 없다. → 별도 프로그램을 설치하지 않아도 된다는 의미
  - 단, 최초 P2P 통신을 수립하기 위해서는 시그널 서버라는 중계 서버를 최초 1회 거쳐야만 한다.

<br>

### 2) 장/단점

#### (1) 장점

- 낮은 Latency
- 시그널링 과정 이후에는 P2P 방식으로 브라우저끼리 통신하기 때문에 서버가 필요없어 낮은 대역폭과 서버 부하를 줄일 수 있음
- 사용자들이 통신을 위해 소프트웨어 및 플러그인을 설치하지 않아도 됨
- 개발 진입 장벽이 낮음
  - 정확히 말해서는 사용이 쉽기 때문에 간단한 개발은 쉽지, 실제로 잘 사용하려면 네트워크 등도 신경써야 해서 복잡함.
- 무료(오픈 소스)

#### (2) 단점

- 호환성 문제 → 모든 웹 브라우저가 Web RTC를 지원하는 것이 아님. IE 같은 경우 지원하지 않고 오래된 버전이면 제대로 동작하지 않을 수도 있음
- 네트워크 문제 → 브라우저 간 통신을 하기 때문에 방화벽이나 NAT, 프록시 서버와 같이 네트워크 구성요소에 의해 영향을 받음
- 성능 문제

<br>

### 3) vs. 웹 소켓 방식

P2P로 브라우저 간 HTTP로 소통하는 것이 아니라 웹 소켓 서버를 통해서 데이터를 주고 받는 방법도 있다.

3-way Handshake 과정을 거쳐서 통신을 맺고, 양방향 소통이 가능하다는 특징이 있음.

그러나 웹 소켓 방식은 서버의 중요성이 커진다는 단점이 존재한다.

실시간 소통이 중요하기 때문에 메모리와 같은 서버의 성능이 매우 중요하며, 요청을 받으면 응답을 리턴하면 끝인 HTTP 방식과 달리 응답에 대한 수신 또한 중요함.

따라서 성능을 해결하지 못하면 사용자 경험이 현저히 떨어지기 때문에 web RTC를 사용하는 것이다.

<br>

## 2. Web RTC 통신 과정

![image](https://github.com/siwon-park/cs-study-for-interview/assets/93081720/8b5eb0da-8c49-4618-9086-7740a5910ff6)

Web RTC 통신을 위해서는 `시그널링(Signaling)`이라는 과정을 통해 `Peer`간 정보를 교환하는 절차가 필요하다.

- IP, 네트워크 구성 정보, 세션 제어 메세지, 미디어 기능 정보 등을 교환한다.

모든 정보를 교환하고 나면 Web RTC API를 활용하여 브라우저간 P2P 방식으로 실시간으로 통신을 한다.

### 1) 시그널링(signaling)

시그널링은 P2P 통신을 위해 사전에 완료되어야 하는 과정이며, 다음과 같은 세 가지 주요 정보를 교환한다.

- 세션 제어 메세지(Session Control Message)
  - 통신의 초기화, 종료와 에러 메세지
- 네트워크 구성 정보(Network Configuration)
  - 외부에서 바라보는 포트와 IP
  - candidate(후보)와 ICE 프레임워크
- 미디어 기능 정보(Media Capabilities):
  - 상호 다른 두 디바이스의 브라우저에서 사용 가능한 미디어 정보(코덱, 해상도 등)
  - SDP 프로토콜

<br>

### 2) 시그널링 중계 서버(STUN/TURN 서버)

Web RTC 통신을 위해 시그널링이라는 과정이 필요하다고 했다. 이 시그널링을 도와주는 중계 서버를 시그널링 서버라고 하며, `STUN/TURN` 서버에 의해 이뤄진다.

![140601803-7afaa474-3a8f-4026-b9f7-34d08ffef80f](https://github.com/siwon-park/cs-study-for-interview/assets/93081720/ad29ef6b-dc1f-4fca-8bdd-52698265ff50)

#### (1) 중계 서버의 필요성(NAT Traversal)

중계 서버가 필요한 이유는 생각보다 매우 간단한데, 두 브라우저가 통신을 원한다고 하자.

그런데 여기서 생각해보면 `"이제 뭘 할 것인가?"`라는 생각이 들어야 정상이다. 서로 통신을 하고 싶은 것은 알겠는데, 중요한 것은 `어디로 데이터를 보내야 할 지 모른다.` 심지어는 `자기 자신의 공인 IP도 모르는 경우`가 허다하다.

서로 다른 주체가 TCP/IP 통신을 하기 위해서는 당연하게도 `IP 주소`와 `포트`를 알아야 한다.

즉, 서로 통신하고자 하는 주체(`Peer`)가 누구인지, 그 주체의 라우터(공유기)의 공인 IP 주소와 포트는 어떻게 되어 있는지 등을 파악하기 위해 중계 서버가 필요한 것이다.

※ `NAT 트래버셜(NAT Traversal)`: 공인 IP와 포트를 찾고 라우터 및 방화벽을 통과해 연결할 방법을 찾는 과정

#### (2) STUN 서버

> **S**ession **T**raversal **U**tilities for **N**AT Server

STUN은 `디바이스가 자신의 공인 IP 주소와 포트를 확인하는 과정`에 대한 프로토콜이다.

클라이언트가 STUN 서버로 요청을 보내면 공인 IP 주소와 함께 통신을 위해 필요한 정보들을 보내주고, 클라이언트는 이렇게 받은 정보를 이용해서 다른 기기와 통신을 하는 것이다.

![image](https://github.com/siwon-park/cs-study-for-interview/assets/93081720/e66906d9-6d3a-4e51-9149-ffdbe9d59e1d)

만약 STUN 서버로 이러한 정보를 얻을 수 없다면 TURN 서버를 사용해서 통신을 한다. 

#### (3) TURN 서버

> **T**raversal **U**sing **R**elay **N**AT

방화벽 정책이나 네트워크 연결 제한 때문에 STUN 서버를 이용해서 자신의 네트워크 정보를 알아낼 수 없는 경우, TURN 서버를 이용한다.

어떤 네트워크에서는 이전에 연결한 적이 있는 네트워크만 연결할 수 있는 Symmetric NAT 정책으로 연결 제한을 두기도 한다.

이러한 제약 조건을 우회하기 위해 TURN 서버와 연결을 맺고, TURN 서버로 패킷을 보내고 서버가 이를 포워딩 하는 방식으로 통신이 이루어진다.

그러나 이 방법은 모든 작업을 한 서버 내에서 처리하는 만큼 서버에 부하가 발생할 수도 있다는 단점이 있다.

![image](https://github.com/siwon-park/cs-study-for-interview/assets/93081720/0f003738-6d91-4d10-8f9e-706dff25c0dc)

<br>

### 3) Candidate와 ICE

#### (1) Candidate(후보)

STUN/TURN 서버를 통해 얻은 IP 주소, 포트 등의 네트워크 구성 정보들의 조합으로 연결 가능한 네트워크 주소들을 `candidate(후보)`라고 부른다.

후보에는 다음과 같은 정보들이 포함되어 있다.

- 자신의 사설 IP와 포트
- 자신의 공인 IP와 포트(STUN/TURN 서버를 통해 획득)
- TURN 서버의 IP와 포트(TURN 서버를 통해서 획득 시)

#### (2) ICE(Interactive Connectivity Establishment)

위의 이러한 과정이 일어나는 곳이 ICE라는 프레임워크이다.

ICE는 두 개의 디바이스가 P2P 연결을 할 수 있도록 최적의 경로를 찾아주는 프레임워크이다.

ICE는 STUN과 TURN 서버를 활용하여 여러 candidate를 검출하고 이들 중 하나를 선택하여 Peer 간의 연결을 수행한다.

<br>

### 4) SDP

> Session Description Protocol

세션 설명 프로토콜(SDP; Session Description Protocol)란 미디어의 해상도, 코덱, 형식 등의 멀티미디어 컨텐츠 세션의 설명을 위한 프로토콜이다. SDP는 세션의 특성과 메타 데이터, 미디어 스트림의 속성, 코덱, 비트레이트, 밴드위스, 프로토콜 등을 포함하며, 이들이 텍스트 형태로 명시되어 있다.

WebRTC에서는 SDP를 사용하여 Peer 간에 미디어를 교환하기 위한 세션 정보를 교환한다. 이것을 교환하는 이유는 통신을 위한 연결은 하는데, 어떤 미디어로 통신할지, 해당 미디어의 정보는 어떻게 되는지 등은 아직 정하지 않았기 때문에 필요한 것이다.

P2P에서 서로 통신할 수 있게 해주는 중요한 프로토콜이다. 즉, 서로 어떤 미디어로, 어떤 미디어 정보로 통신할지 결정하여 통신하게 해주는 역할을 한다.

- 브라우저는 SDP를 생성하여 로컬 미디어 및 네트워크 정보(세션 정보)를 상대방에게 보낸다.
- 상대방 브라우저는 받은 SDP를 사용하여 자신의 로컬 미디어와의 연결을 설정한 뒤 응답 SDP를 생성하여 보낸다.
- 이러한 교환 과정을 통해 미디어 통신이 설정되고 스트림이 교환되는 것이다.

##### ※ RTMP(Real Time Messaging Protocol; RTMP)

리얼타임 메세징 프로토콜.

어도비 시스템즈에서 개발한 멀티미디어 전송 프로토콜로, 오디오, 비디오 및 기타 데이터를 인터넷을 통해 스트리밍할 때 쓰이는 프로토콜이다. 유튜브나 스트리밍 미디어 서비스 등에서 사용하고 있다.

클라이언트와 서버 간의 미디어 통신에 쓰이나 최근에는 HTTP 기반의 스트리밍 기술이 보다 더 널리 사용되는 추세이다.

<br>

## 3. Web RTC 핵심 API

### 1) getUserMedia

사용자의 디바이스의 미디어 장치(마이크, 웹캠 등)에 엑세스할 수 있는 방법을 제공하는 API.

getUserMedia API를 통해 미디어 장치에 엑세스하게 되면 미디어 스트림 객체를 얻을 수 있는데, 이를 `PeerConnection`에 전달하여 미디어 스트림을 전송하는 것이다.

### 2) PeerConnection

Peer 간의 화상/음성 등의 미디어 데이터를 교환하기 위한 핵심 API.

### 3) DataChannel

Peer 간의 텍스트나 파일을 주고 받을 수 있는 메세징 API.

웹 소켓(Web Socket)과 같은 Row Level API이며, web RTC를 활용하여 파일을 주고 받기 위해서는 DataChannel API에 대한 이해가 필요하다.