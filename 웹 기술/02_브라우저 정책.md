# 02_브라우저 정책

> SOP, CORS

## 1. SOP

> Same-Origin Policy (동일 출처 정책)

해킹 및 악의적인 공격을 방지하기 위한 정책으로, 출처(Origin)이 동일한 경우에만 리소스를 공유할 수 있도록 브라우저에서 제한하는 보안 정책을 말한다.

### 1) 출처(Origin)

![image](https://github.com/user-attachments/assets/94cebbc7-6c10-4d11-854e-187d49a022d8)

URL에서 출처가 동일하다는 말은 `프로토콜(스킴), 호스트(도메인명), 포트` 이 3가지가 동일하다는 것이다.

이 때, 포트 번호의 경우 생략되었다면 기본 포트(예- http 80, https 443)을, 명시되어 있다면 명시된 포트 번호를 기준으로 한다.

#### (1) 예시

- `http://example.com/hello`와 `http://example.com/bye`는 다른 url이지만 프로토콜, 호스트, 포트 3가지가 모두 같기 때문에 동일 출처이다.
- `http://example.com`과 `https://example.com`은 프로토콜이 다르기 때문에 동일 출처가 아니다.
- `http://example.com`과 `http://example.com:80`은 프로토콜, 호스트, 포트(http와 80)이 같기 때문에 동일 출처이다.

<br>

### 2) 등장 배경

외부 서버로부터 다운받은 스크립트를 통해 DOM을 조작하거나 CSRF, XSS 등의 공격을 통해 타 브라우저를 공격하거나 민감한 정보를 탈취하는 악의적인 공격들을 막기 위해 등장하였다.

과거에는 브라우저 간 통신할 일이 많지 않았고, 하더라도 같은 도메인 내에서만 국한되었기에 충분히 출처가 다른 곳으로 요청을 주고 받는 것에 대해 악의적인 행위로 간주하는 것이 자연스러웠다. (물론 현재에는 출처가 다른 곳과 요청을 주고 받는 것이 당연하다.)

<br>

### 3) SOP 정책 상 허용되는 것

- script: 다른 출처의 스크립트를 문서에 삽입하는 것은 가능하지만, 이 스크립트를 통해 다른 출처로 요청을 날리는 것은 불가능하다.
- css: `<link>` 혹은 `@import`로 다른 출처의 css를 삽입하는 것이 가능하다.
- iframe: `X-Frame-Options` 응답 헤더가 `DENY` 혹은 `SAMEORIGIN`이 아닌 이상 일반적으로 다른 iframe을 삽입하는 것은 가능하지만, 자바 스크립트를 이용해서 다른 출처의 iframe에 접근하는 것은 불가능하다.
- form: `<form>` 태그의 `action` 속성 값에 출처가 다른 url을 사용하여 폼 데이터를 전송하는 것이 가능하다.
- image: 다른 출처의 이미지를 삽입하는 것은 가능하지만, 자바 스크립트를 이용해서 다른 출처의 이미지를 읽는 것은 불가능하다.
- multimedia: 다른 출처의 오디오, 비디오를 삽입할 수 있다.

<br>

## 2. CORS

> Cross-Origin Resource Sharing (교차 출처 리소스 공유)

웹 기술이 발전함에 따라 점차 서비스 간 직접적인 API 호출을 통해서 소통해야 하는 상황이 많아졌는데, SOP 정책으로 인해서 제한되는 내용이 많아서 일반적인 방법으로는 불가능했다.

이를 극복하기 위해 등장한 개념이 교차 출처 리소스 공유(CORS)이며, 리소스 호출이 허용된 출처를 서버가 명시해두면 출처가 다르더라도 요청과 응답을 주고 받을 수 있는 정책을 말한다.

### 1) ⭐유의사항

단, 중요한 것은 SOP, CORS 모두 `브라우저의 정책`이며, 다른 출처의 리소스를 제한하는 것이 서버가 아니라 클라이언트인 브라우저라는 것에 유의해야 한다. (서버는 응답을 반환하지만, 브라우저에서 해당 응답을 정책 위반 시 차단하고 버리는 것이다.)

따라서 브라우저에서는 CORS 정책으로 인해 차단되는 요청도 Postman과 같은 브라우저가 아닌 환경에서 서버 to 서버로 직접 통신했을 때는 원할하게 이뤄질 수도 있다.

그래서 Postman으로 백엔드 서버로 요청을 했을 때, "정상적으로 작동하네?"라고 생각하고, 실제 프로젝트를 배포했지만 CORS 정책으로 인해 문제가 생기는 일이 종종 발생한다.

#### (1) 기본 동작

- 브라우저는 다른 출처로 요청을 보낼 때 기본적으로 HTTP 헤더(header)에 `Origin`을 추가하여 보낸다.
- 요청을 받은 서버는 응답 헤더에 `Access-Control-Allow-Origin`에 허가된 출처 정보를 담아서 응답을 보낸다.
- 즉, 브라우저는 요청의 Origin 헤더에 담긴 출처 정보가 응답의 Access-Control-Allow-Origin 헤더에 담긴 정보와 같으면 헤당 응답을 안전하다고 간주하고 가져오고, 그렇지 않다면 해당 응답을 임의로 파기하여 버린다.



<br>

### 2) 단순 요청 (Simple Requests)

단순 요청으로 취급될 경우에는 CORS를 만족하는지 확인은 하나 절차가 비교적 간소화된다. (pre-flight 생략)

#### (1) 단순 요청이 필요한 이유?

굳이 쓸데 없이 pre-flight(사전 요청)하는 과정을 생략하기 위함이다. 사전 요청을 하게 되면 아무래도 결국에는 1번의 요청이지만 실제로는 총 2번의 요청을 보내는 것이기 때문에 트래픽과 리소스적인 측면에서는 비효율적일 수 밖에 없다.

#### (2) 단순 요청의 조건

- 메서드: GET, POST, HEAD
- 헤더: Accept, Accept-Language, Content-Language, Content-Type
- Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain

그러나 일반적으로 Content-Type은 application/json을 많이 사용하며 인증을 위해서 헤더 값에 Cookie나 Authorization과 같은 추가 헤더를 사용하기 때문에 단순 요청의 조건을 만족하기란 쉽지 않다.

![image](https://github.com/user-attachments/assets/5527585e-b4cd-48a8-8250-a081864430ea)

<br>

### 3) 프리플라이트 요청 (Pre-flight Requests)

실제 요청을 보내기 전에 사전에 요청을 보내서 해당 리소스에 접근이 가능한지 확인하는 방식을 pre-flight 방식이라고 한다.

마치 "이런 메서드와 헤더로 요청을 보낼 건데 너희 정책이 허용하는 요청이니?"하고 먼저 물어보는 것이다.

#### (1) pre-flight가 필요한 이유?

CORS는 서버가 아닌 브라우저의 정책이지만, 그럼에도 불구하고 미리 확인을 하는 이유는 서버는 일단 요청이 들어오면 처리 후 응답을 보내게 된다.

이 때, 만약 요청의 타입이  GET과 같은 단순 조회 요청일 경우엔 문제 없지만 POST, PUT, DELETE와 같은 메서드일 경우에는 잘못될 경우 서버에 부작용을 일으킬 수도 있다.

따라서 pre-flight는 실제 요청이 CORS를 위반하지는 않았는지 미리 확인함과 동시에 부작용으로부터 서버를 보호하기 위해 존재한다.

![image](https://github.com/user-attachments/assets/b7c6086d-71c9-4f9f-88ba-497c5106ede0)

#### (2) 특징

pre-flight 요청은 브라우저에서 자동 전송되기 때문에 직접 설정을 할 필요는 없다.

다만, Postman과 같은 API Test 도구 앱들에서는 브라우저가 아니기 때문에 pre-flight를 보내지 않는다는 것을 유의.

<br>

### 4) 인증 요청 (Crendential Requests)

쿠키, 토큰과 같은 인증 정보를 포함한 요청.

사용자 식별 정보가 담긴 요청의 경우 조금 더 엄격한 수준으로 CORS가 적용된다.

인증 정보가 포함된 요청일 경우 서버는 `Access-Control-Allow-Credentials`라는 헤더값을 `true`로 설정해줘야 하고 `Access-Control-Allow-Origin` 헤더값은 절대 와일드 카드(`*`)가 될 수 없어 반드시 명확한 출처를 명시해줘야 한다.

위 2가지 조건을 만족시키지 못하면 CORS 정책을 위반한 것으로 간주한다.



